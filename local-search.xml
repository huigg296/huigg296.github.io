<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PhotoShop新手上路</title>
    <link href="/post/2024050421.html"/>
    <url>/post/2024050421.html</url>
    
    <content type="html"><![CDATA[<p>此前，我没有PhotoShop设计经验，有印象的只有高考完暑假后无聊跟着PhotoShop官方教程做了一些基础操作，我大致知道它提供了哪些功能，是怎样的工作逻辑，然而具体怎么操作早就忘记了。最近正在捣腾痛车设计，所以不得不以完全小白的状态入门摸索这款软件。</p><p>刚开始操作确实很不适应，连移动图像都不知道该怎么做，狂点鼠标也没反应。但无奈没有时间慢慢学习，只能不懂就google。下面使用PhotoShop 2023，记录简单的上手操作。</p><h1 id="概念与基本操作"><a href="#概念与基本操作" class="headerlink" title="概念与基本操作"></a>概念与基本操作</h1><h2 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h2><p><code>画布</code>是你能进行操作的区域，就像是一张实际的画纸一样，所有图像只能在画纸上展示。</p><p><code>画布</code>的三个属性最为关键：<code>大小</code>，<code>颜色模式</code>，<code>分辨率</code>。</p><ul><li><p><code>大小</code>： 最终图像总会以某种形式打印出来，因此需要指定打印的样式</p></li><li><p><code>颜色模式</code>： 不同的颜色模式有不同的优势，如<code>CMYK</code>是打印用的颜色模式，使用该颜色模式基本可以“所绘即所得”。</p></li><li><p><code>分辨率</code>： 物理距离对应的像素的数量，越高图像越清晰</p></li></ul><h2 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h2><p><code>图层</code>是PhotoShop的基础图像编排逻辑，在PowerPoint软件中操作过也基本能理解，<code>图层</code>的上下级关系等等。</p><ul><li><p>拷贝：光标选中<code>图层</code>，<code>Ctrl-c</code> + <code>Ctrl-v</code> 即可。如果此时图像中有<code>选区</code>, 则只会拷贝该选区中的元素</p></li><li><p>重命名：双击图层的名字进行重命名</p></li><li><p>移动、旋转、缩放：<code>编辑&gt;变换</code> or <code>Ctrl-t</code></p></li></ul><h1 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h1><h2 id="编辑历史记录"><a href="#编辑历史记录" class="headerlink" title="编辑历史记录"></a>编辑历史记录</h2><p>在<code>窗口</code>中打开<code>历史记录</code>，可以直观地看到自己的操作，方便撤回与重做。</p><h2 id="导航器"><a href="#导航器" class="headerlink" title="导航器"></a>导航器</h2><p>在<code>窗口</code>中打开<code>导航器</code>，可以看到当前视角在整体图像的位置，很舒服。</p><h2 id="标尺"><a href="#标尺" class="headerlink" title="标尺"></a>标尺</h2><p>在<code>视图</code>中打开<code>标尺</code>，或者按<code>Ctrl+r</code>，可以看到量画布的标尺，从标尺上拖动鼠标，可以绘制辅助线，非常实用。</p><h1 id="功能导向"><a href="#功能导向" class="headerlink" title="功能导向"></a>功能导向</h1><h2 id="抠图"><a href="#抠图" class="headerlink" title="抠图"></a>抠图</h2><p>我们常常需要从网络获取素材，并在素材中抠出我们想要的部分，把不想要的部分弄成透明，这就是抠图。抠图一般是件伤时费神的工作，尤其是画面主体比较复杂（比如毛发）或者背景比较复杂的时候。在PhotoShop中有多种抠图的方法，分别适用于不同的场景。</p><h3 id="1-魔术橡皮擦"><a href="#1-魔术橡皮擦" class="headerlink" title="1. 魔术橡皮擦"></a>1. 魔术橡皮擦</h3><p><code>魔术橡皮擦</code>的原理是：消除点击区域相同颜色的像素。因此，如果背景是纯色的，用它可以快速地去除背景。但是如果画面主体比较复杂（比如毛发很多），在主体的边缘由于颜色的混杂，可能会残留一些背景，这时依然需要慢慢用<code>橡皮擦</code>工具修。</p><h3 id="2-磁性套索工具"><a href="#2-磁性套索工具" class="headerlink" title="2. 磁性套索工具"></a>2. 磁性套索工具</h3><p><code>磁性套索工具</code>会自动吸附检测到的边缘。在主体与背景对比度较高，且不太复杂时，用起来还是很舒服的，只需用鼠标慢慢绕一圈，然后拷贝选区即可。如果画面主体比较复杂（比如毛发很多），那简直就是噩梦。</p><h2 id="3-选择主体"><a href="#3-选择主体" class="headerlink" title="3. 选择主体"></a>3. 选择主体</h2><p>点击<code>选择&gt;主体</code>，PhotoShop遍会自动识别画面的主体，并生成选区。但是往往只能适用于图像很简单的情况。</p><h2 id="边缘发光"><a href="#边缘发光" class="headerlink" title="边缘发光"></a>边缘发光</h2><p>提到这个，其实我们是在谈论如何设置<code>图层样式</code>。边缘发光只是<code>图层样式</code>中的一种。右键当前<code>图层</code>，点击<code>混合选项</code>，可以看到PhotoShop提供了多种样式。这里想做<code>外发光</code>,于是就在<code>外发光</code>选项卡下调各种参数，主要把<code>结构</code>和<code>图素</code>的参数整好就行，<code>品质</code>参数不知道干什么用的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>PS</tag>
      
      <tag>软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>痛车设计从入门到放弃</title>
    <link href="/post/2024050420.html"/>
    <url>/post/2024050420.html</url>
    
    <content type="html"><![CDATA[<p>课题组里的师兄花了两年整了一套通用的实验机器人，马上就要到量产阶段了。适逢我刚正式加入课题组，同时感受到本人浓厚的二次元气息， 便把设计第一辆机器人涂装的任务交给了我。（虽然我很想吐槽这个决定是有多么抽象）</p><p>其实一开始我是拒绝的.jpg。直到……..我看完了2023魔法未来演唱会，主题曲《Hero》既毒到让我连刷好多遍，又让我每遍都深受感动。虽然只是录像，但现场的气氛着实让我倍受感染。</p><blockquote><p>ハッピーバースデー, 親愛なるヒーローへ 🎶</p><p>祝你生日快乐，我亲爱的英雄 🎶</p></blockquote><p>而且，miku这身装束，虽然一反平时甜美的感觉，甚至初看觉得奇怪。但是在《HERO》舞台表现太亮眼了，现在我的感想只剩下：实在太飒啦啊啊啊！！！[图片来源于<a href="https://magicalmirai.com/2023/index_tw.html">2023魔法未来官方视觉图</a>]</p><img src="/post/2024050420/visual_miku.jpg" class="" title="2023魔法未来视觉图"><p>于是乎，一个零设计基础的小白持枪上阵了。</p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="究竟什么是痛车"><a href="#究竟什么是痛车" class="headerlink" title="究竟什么是痛车"></a>究竟什么是痛车</h2><h2 id="当我们说要做痛车，我们究竟要做什么"><a href="#当我们说要做痛车，我们究竟要做什么" class="headerlink" title="当我们说要做痛车，我们究竟要做什么"></a>当我们说要做痛车，我们究竟要做什么</h2><h2 id="不需要成为专业的设计师也能做痛车，最重要的是热爱"><a href="#不需要成为专业的设计师也能做痛车，最重要的是热爱" class="headerlink" title="不需要成为专业的设计师也能做痛车，最重要的是热爱"></a>不需要成为专业的设计师也能做痛车，最重要的是热爱</h2><h1 id="痛车设计之路"><a href="#痛车设计之路" class="headerlink" title="痛车设计之路"></a>痛车设计之路</h1><h2 id="1-确定尺寸图"><a href="#1-确定尺寸图" class="headerlink" title="1. 确定尺寸图"></a>1. 确定尺寸图</h2><h2 id="2-获取素材"><a href="#2-获取素材" class="headerlink" title="2. 获取素材"></a>2. 获取素材</h2><h2 id="3-找到最养眼的设计"><a href="#3-找到最养眼的设计" class="headerlink" title="3. 找到最养眼的设计"></a>3. 找到最养眼的设计</h2><h2 id="4-交付打印"><a href="#4-交付打印" class="headerlink" title="4. 交付打印"></a>4. 交付打印</h2><h2 id="5-粘贴"><a href="#5-粘贴" class="headerlink" title="5. 粘贴"></a>5. 粘贴</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>PS</tag>
      
      <tag>二次元</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo blog从0到1</title>
    <link href="/post/2024050419.html"/>
    <url>/post/2024050419.html</url>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li><p>安装npm</p></li><li><p>安装hexo</p></li><li><p>托管github page</p></li></ul><h1 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h1><ul><li><p>主题是什么</p></li><li><p>Fluid主题与相关配置</p></li></ul><h1 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h1><ul><li><p>如何发布一篇博客</p></li><li><p>博客源文件存档</p></li><li><p>常用语法与规则</p></li></ul><h2 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h2><ul><li>文章url的好看设置</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CloudCompare和MeshLab的一些方便用法</title>
    <link href="/post/2024042713.html"/>
    <url>/post/2024042713.html</url>
    
    <content type="html"><![CDATA[<h1 id="CloudCompare"><a href="#CloudCompare" class="headerlink" title="CloudCompare"></a>CloudCompare</h1><blockquote><p>3D point cloud and mesh processing software Open Source Project</p></blockquote><h2 id="点云渲染"><a href="#点云渲染" class="headerlink" title="点云渲染"></a>点云渲染</h2><h2 id="便捷工具"><a href="#便捷工具" class="headerlink" title="便捷工具"></a>便捷工具</h2><h1 id="MeshLab"><a href="#MeshLab" class="headerlink" title="MeshLab"></a>MeshLab</h1><blockquote><p>The open source system for processing and editing 3D triangular meshes. It provides a set of tools for editing, cleaning, healing, inspecting, rendering, texturing and converting meshes. It offers features for processing raw data produced by 3D digitization tools&#x2F;devices and for preparing models for 3D printing.</p></blockquote><h2 id="三角面片渲染"><a href="#三角面片渲染" class="headerlink" title="三角面片渲染"></a>三角面片渲染</h2><p><a href="https://www.meshlab.net/">MeshLab</a>是操作三角面片模型的工具，常用的三角面片模型文件有<code>.ply</code>文件。<code>.ply</code>文件中记录了三角面片的顶点和面，每个顶点由 x、y 和 z 坐标组成，每个面由顶点索引组成。一个示例的ply文件如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">ply<br><span class="hljs-built_in">format</span> <span class="hljs-built_in">ascii</span> <span class="hljs-number">1.0</span><br>comment Created by ChatGPT<br>element vertex <span class="hljs-number">4</span><br><span class="hljs-built_in">property</span> <span class="hljs-built_in">float</span> x<br><span class="hljs-built_in">property</span> <span class="hljs-built_in">float</span> y<br><span class="hljs-built_in">property</span> <span class="hljs-built_in">float</span> z<br>element face <span class="hljs-number">2</span><br><span class="hljs-built_in">property</span> <span class="hljs-built_in">list</span> uchar <span class="hljs-built_in">int</span> vertex_index<br>end_header<br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>在MeshLab中，在导入文件后，可以在渲染窗格中调整渲染样式，输出漂亮的图片。常用的渲染设置为：</p><ul><li><p>三角面片的顶点</p></li><li><p>三角面片的边</p></li><li><p>三角面片的面</p></li></ul><img src="/post/2024042713/MeshLab%E6%B8%B2%E6%9F%93%E7%AA%97%E6%A0%BC.png" class="" title="MeshLab渲染窗格"><p>一个渲染得很好看的样式如下。或许后续需要将不同地形元素渲染为不同的颜色，不知该如何实现。</p><img src="/post/2024042713/MeshLab%E4%B8%89%E8%A7%92%E9%9D%A2%E7%89%87%E6%B8%B2%E6%9F%93.png" class="" title="MeshLab三角面片渲染"><h2 id="便捷工具-1"><a href="#便捷工具-1" class="headerlink" title="便捷工具"></a>便捷工具</h2><img src="/post/2024042713/MeshLab%E5%B7%A5%E5%85%B7%E6%A0%8F.png" class="" title="MeshLab工具栏"><ul><li><p>相机工具：Save Snapshot， 比屏幕截图质量更高</p></li><li><p>网格工具：Draw a gridded backgroud that can be used as a reference, 作为观察三角面片模型的参照物</p></li><li><p>坐标系工具：Draw XYZ axes in world coordinates, 绘制坐标系，可以用于观察重建的地形是否于世界坐标系一致</p></li><li><p>变换工具：用于平移、旋转模型</p></li><li><p>测量工具：测量两个点之间的距离</p></li><li><p>绘图工具 z-painting: 用于给三角面片上色，输出漂亮的图像</p></li><li><p>PP工具 pick points: 用于选取模型中的点，但不知为何，在ply中无法选取三角形顶点</p></li><li><p>选择工具： point selection &amp; face selection，选取后的点&#x2F;面可以进行删除，观察修剪后的效果</p></li><li><p>info工具：选取某个面片，获取该面片以及它的顶点的信息，非常实用</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>log: 通过双击模型中的某个点，可以让视角聚焦在这个点上，在log中可以看到该点的坐标</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>点云</tag>
      
      <tag>建模</tag>
      
      <tag>软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMware虚拟机网络无法连接问题解决办法</title>
    <link href="/post/2022093000.html"/>
    <url>/post/2022093000.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-经过"><a href="#1-经过" class="headerlink" title="1.经过"></a>1.经过</h2><p>最近在用VMware玩耍。前两天在安装了python3.8和pip后，把虚拟机挂起，在物理机上学习python语法。一段时间后重新打开虚拟机，发现Ubuntu预置的firefox浏览网页报错，显示“安全连接失败”。怀疑是浏览器的问题，Google后各种修改浏览器配置选项也无法解决。于是蠢蠢地准备将重装firefox，发现执行<code>sudo apt update</code>时报错，显示域名无法解析。又发现Ubuntu上chrome也无法浏览网页，这时才检查发现是虚拟机网络的问题。</p><p>在发现问题后，翻阅了很多博客，不断尝试，最终在<a href="https://blog.csdn.net/leadingsci/article/details/80873542">这篇博客</a>上找到解决办法。虚拟机终于可以联网了，好耶! Y(^_^)Y</p><h2 id="2-问题"><a href="#2-问题" class="headerlink" title="2.问题"></a>2.问题</h2><p>linux 设置&gt;界面 显示”未发现Wi-Fi适配器“，且 设置&gt;网络 中没有有线连接选项。</p><img src="/post/2022093000/error.png" class="" title="Network Error"><h2 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3.解决办法"></a>3.解决办法</h2><h3 id="尝试一："><a href="#尝试一：" class="headerlink" title="尝试一："></a>尝试一：</h3><p>一开始，我几乎是病急乱投医。直接搜索”VMware 找不到wifi适配器“寻找解决方法。找到一篇<a href="https://zhuanlan.zhihu.com/p/269139018?utm_source=wechat_session&utm_medium=social&utm_oi=1187090292599066624&utm_campaign=shareopn">《万能的VMware虚拟机连接不上的解决方法》</a>，并没有仔细分析问题是否相同，便按现成的解决方法去莽。结果自然是：无论尝试几次，重启几次，网络依然无法连接。我又找了许多其他博客，介绍的解决方案基本大同小异，尝试后依旧无果。</p><h3 id="尝试二："><a href="#尝试二：" class="headerlink" title="尝试二："></a>尝试二：</h3><p>由于安装虚拟机时我几乎一窍不通，所以我记不得当时是如何配置网络环境的。几番回忆下，我找到了那篇<a href="https://segmentfault.com/a/1190000024580532">Vmware网络配置教程</a>。我的虚拟机是用NAT模式联网的，即与宿主机组成小局域网，通过宿主机访问互联网。这种联网方式下，虽然虚拟机连接的是无线网络，但是设置中显示的是连接有线网络。</p><p>了解了问题大致样貌后，我再去寻找方法，终于找到一篇<a href="https://blog.csdn.net/leadingsci/article/details/80873542">《ubunt18.04虚拟机突然无法上网解决方法》</a>，其中的解决方法大致思路是初始化网路管理器。其提供的解决方法尝试如下：</p><p>1.将模式调整为”主机模式“</p><p>2.输入以下代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service network-manager stop<br><br>sudo rm -i /var/lib/NetworkManager/NetworkManager.state<br><br>sudo service network-manager start<br></code></pre></td></tr></table></figure><p>命令行输入以上短短三行命令后，问题就基本解决了。虚拟机重启后，终于连上了网络！</p><h2 id="4-心得"><a href="#4-心得" class="headerlink" title="4.心得"></a>4.心得</h2><p>虽然问题解决了，但问题发生的具体原因依然不得而知，而且我并不完全了解解决方案的原理。下次发生问题时，可能还要再花一晚上功夫寻找解决方法。但这些付出还是值得的，我收获了很多经验，最后解决问题时的愉悦心情也是很棒的体验。</p><p>希望随着自己不断学习、实践，将来能对这个问题有更好的理解。加油吧。</p><h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5.参考文献"></a>5.参考文献</h2><p>&lt;1&gt; <a href="https://www.cnblogs.com/Courage129/p/14287850.html">《NAT模式、路由模式、桥接模式的区别 - 等不到的口琴 - 博客园》</a></p><p>&lt;2&gt; <a href="https://segmentfault.com/a/1190000024580532">《VmWare网络配置，只此一篇就够了》</a></p><p>&lt;3&gt; <a href="https://zhuanlan.zhihu.com/p/269139018?utm_source=wechat_session&utm_medium=social&utm_oi=1187090292599066624&utm_campaign=shareopn">《万能的VMware虚拟机连接不上的解决方法》</a></p><p>&lt;4&gt; <a href="https://blog.csdn.net/leadingsci/article/details/80873542">0058-【linux系统】-ubunt18.04虚拟机突然无法上网解决方法_伍泳彰的博客-CSDN博客</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Python爬取网络数据到Excel</title>
    <link href="/post/2022092600.html"/>
    <url>/post/2022092600.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><h3 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h3><p>近来笔者在浅尝python网络爬虫，这是笔者写的第一个爬虫程序，仅仅是一步步按参考书的教程写成。写这篇博客仅为备忘用，没有什么技术含量，如果能对你有所帮助，那也再好不过。</p><p>我们以爬取<a href="https://www.kugou.com/yy/rank/home/1-8888.html">酷狗歌曲TOP500</a>为例，获取网页上显示的TOP500的歌曲名、歌手、歌曲时长，并将结果输出到一个Excel表格中。</p><h3 id="1-2-环境与准备"><a href="#1-2-环境与准备" class="headerlink" title="1.2 环境与准备"></a>1.2 环境与准备</h3><ul><li><p>Ubuntu 18.04</p></li><li><p>python 3.8</p></li><li><p>python库：Requests，BeautifulSoup4</p></li><li><p>chrome &#x2F; firefox浏览器</p></li><li><p>一双敲代码的小手</p></li><li><p>一个不畏bug的大心脏</p></li></ul><h2 id="2-HTML爬取"><a href="#2-HTML爬取" class="headerlink" title="2. HTML爬取"></a>2. HTML爬取</h2><p>第一步就是直接步入主题，用程序请求网站获取网页html文件。我们要做的事情就是：</p><ol><li><p>加入请求头来伪装成浏览器</p></li><li><p>向目标网站发送http请求</p></li><li><p>获取服务器响应的html文件</p></li></ol><p>应用“让HTTP服务人类”的Requests库，我们能够用一行代码实现这些操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36&quot;</span><br>&#125;<br>wb_data = requests.get(<span class="hljs-string">&#x27;https://www.kugou.com/yy/rank/home/1-8888.html&#x27;</span>,headers=headers)<br></code></pre></td></tr></table></figure><p>其中，请求头可以从chrome浏览器的 开发者工具 &gt; 网络 中查询。如此我们便获得了酷狗TOP500第一页的html文档，可以用<code>print(wb_data.text)</code>查看其内容。</p><p>有些网站具备反爬机制，这时print出来的结果可能是缺斤少两、奇奇怪怪的，这时就需要爬虫与反爬虫进行更高级的智斗了。所幸酷狗网页并没有反爬机制，我们可以很愉快地获取网页内容。</p><p>插一句，如果要爬取国外的网站，得先保证网络能够使浏览器正常访问网站，没有vpn的话可能会报错。</p><h2 id="3-HTML解析"><a href="#3-HTML解析" class="headerlink" title="3. HTML解析"></a>3. HTML解析</h2><p>但是，我们得到的html文档内容太复杂了，真是看得人头大，我们怎样才能从这些奇怪的标记中找到我们需要的信息呢？</p><p>这时就该BeautifulSoup库派上用场啦，它可以对HTML&#x2F;XML文档进行解析，将网页源代码解析为Soup文档，以便过滤提取数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(wb_data.text,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这时再进行<code>print(soup.prettify())</code>可以看到解析后的Soup文档，看上去与原来的html文档没什么不同，但通过BeautifulSoup解析得到的Soup文档按章标准缩进格式的结构输出，为结构化数据的过滤提取做好准备。</p><h2 id="4-数据提取"><a href="#4-数据提取" class="headerlink" title="4. 数据提取"></a>4. 数据提取</h2><p>终于到最重要的数据提取了。我们需要的数据到底在哪里？我们怎样把它们提取出来？</p><p>这里以提取“歌曲名称”为例，用chrome浏览器开发者工具中的“检查元素”功能，我们可以找到歌曲名称属标签在html文档的位置。鼠标右击标签，选择复制selector，这就是“歌曲名称”所属标签在html中的定位（好像也是用CSS制作样式时的定位方式）。</p><p>注意：将<code>li:nth-child(1)</code>中的伪类删去，即改为<code>li</code>，以获得整个页面22个歌曲名称。</p><p>接着我们就可以用BeautifulSoup中的<code>select()</code>方法找到“歌曲名称”在Soup文档中的位置，用<code>get_text()</code>方法获取title属性中的文本（也可以用<code>get()</code>方法获取其他属性值），再进行字符串处理，就可以得到“歌曲名称”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">titles = soup.select(<span class="hljs-string">&#x27;#rankWrap &gt; div.pc_temp_songlist &gt; ul &gt; li &gt; a&#x27;</span>)<br><span class="hljs-keyword">for</span> title <span class="hljs-keyword">in</span> titles:<br>    data = &#123;<br>        <span class="hljs-string">&#x27;song&#x27;</span>:title.get_text(strip=<span class="hljs-literal">True</span>).split(<span class="hljs-string">&#x27;-&#x27;</span>)[<span class="hljs-number">0</span>]<br>&#125;<br><span class="hljs-built_in">print</span>(data)<br></code></pre></td></tr></table></figure><p>注：这里发现，在html中，title属性值为“歌手-歌曲名称”，但在使用方法<code>get_text()</code>后，提取出内容为“歌曲名称-歌手”。目前不清楚原因，之后可能要去翻阅下官方文档。</p><h2 id="5-导入Excel"><a href="#5-导入Excel" class="headerlink" title="5. 导入Excel"></a>5. 导入Excel</h2><p>最后我们将提取到的数据导入到Excel表格中。这里只需要用到openpyxl库，就能够轻松实现工作簿编辑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<br>workbook = Workbook()<br>sheet = workbook.active<br>row = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> title <span class="hljs-keyword">in</span> titles:<br>    row += <span class="hljs-number">1</span><br>    sheet[<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-built_in">str</span>(row)].value = title.get_text(strip=<span class="hljs-literal">True</span>).split(<span class="hljs-string">&#x27;-&#x27;</span>)[<span class="hljs-number">0</span>]<br>workbook.save(<span class="hljs-string">&#x27;songs_TOP500.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行后发现当前目录下出现一个名为“songs_TOP500.xlsx”的xlsx文件，工作表中A列记录了歌曲名称。</p><h2 id="6-最终代码与运行结果"><a href="#6-最终代码与运行结果" class="headerlink" title="6. 最终代码与运行结果"></a>6. 最终代码与运行结果</h2><h3 id="6-1-在最终代码前"><a href="#6-1-在最终代码前" class="headerlink" title="6.1 在最终代码前"></a>6.1 在最终代码前</h3><p>基本工作已经完成，现在只需注意两点：</p><ol><li><p>TOP500在23个网页html上，需根据url特点构造url列表，爬取这23个页面；</p></li><li><p>每次爬取网页需暂停0.5~1s，防止请求过快，触发网站的反爬程序</p></li></ol><h3 id="6-2-最终代码（仅供参考）"><a href="#6-2-最终代码（仅供参考）" class="headerlink" title="6.2 最终代码（仅供参考）"></a>6.2 最终代码（仅供参考）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 2022.9.28</span><br><span class="hljs-comment"># 根据参考书上样例爬取酷狗Top500的歌手、歌名和歌曲时长等信息</span><br><br><span class="hljs-comment"># 必要库调用</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 伪装浏览器请求头</span><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0Safari/537.36&quot;</span><br>&#125;<br>workbook = Workbook()<br>sheet = workbook.active<br>columns = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>]<br>row = <span class="hljs-number">0</span><br><br><br><span class="hljs-comment"># 定义获取信息的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_info</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-comment"># 爬取网页</span><br>    wb_data = requests.get(url, headers=headers)<br>    soup = BeautifulSoup(wb_data.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>    <span class="hljs-comment"># 提取信息</span><br>    ranks = soup.select(<span class="hljs-string">&#x27;#rankWrap &gt; div.pc_temp_songlist &gt; ul &gt; li &gt; span.pc_temp_num&#x27;</span>)<br>    titles = soup.select(<span class="hljs-string">&#x27;#rankWrap &gt; div.pc_temp_songlist &gt; ul &gt; li &gt; a&#x27;</span>)<br>    times = soup.select(<span class="hljs-string">&#x27;#rankWrap &gt; div.pc_temp_songlist &gt; ul &gt; li &gt; span.pc_temp_tips_r &gt; span&#x27;</span>)<br><br>    <span class="hljs-comment"># 调整输出</span><br>    <span class="hljs-keyword">for</span> rank, title, time <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(ranks, titles, times):<br>        data1 = rank.get_text().strip()<br>        data2 =  title.get_text(strip=<span class="hljs-literal">True</span>).split(<span class="hljs-string">&#x27;-&#x27;</span>)[<span class="hljs-number">1</span>]<br>        data3 = title.get_text(strip=<span class="hljs-literal">True</span>).split(<span class="hljs-string">&#x27;-&#x27;</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 发现get_text()后，歌手和歌名顺序颠倒，原因未知</span><br>        data4 = time.get_text().strip()<br>        listemp = [data1,data2,data3,data4]<br>        data = &#123;<br>            <span class="hljs-string">&#x27;rank&#x27;</span>: data1,<br>            <span class="hljs-string">&#x27;singer&#x27;</span>: data2,<br>            <span class="hljs-string">&#x27;song&#x27;</span>: data3,<br>            <span class="hljs-string">&#x27;time&#x27;</span>: data4<br>        &#125;<br>        <span class="hljs-built_in">print</span>(data)<br>        <span class="hljs-comment">#写入Excel</span><br>        <span class="hljs-keyword">global</span> row<br>        row += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> col, temp <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(columns, listemp):<br>            sheet[col+<span class="hljs-built_in">str</span>(row)].value = temp<br><br><br><span class="hljs-comment"># 程序主入口</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    urls = [<span class="hljs-string">&#x27;https://www.kugou.com/yy/rank/home/&#123;&#125;-8888.html&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(i))<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">24</span>)]<br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br>        get_info(url)<br>        time.sleep(<span class="hljs-number">0.5</span>)<br>    workbook.save(<span class="hljs-string">&#x27;songs_TOP500.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="6-3-运行结果"><a href="#6-3-运行结果" class="headerlink" title="6.3 运行结果"></a>6.3 运行结果</h3><img src="/post/2022092600/Excel%E5%AF%BC%E5%85%A5%E6%88%90%E5%8A%9F.png" class="" title="Excel导入成功"><img src="/post/2022092600/%E5%AD%97%E5%85%B8%E8%BE%93%E5%87%BA%E6%88%90%E5%8A%9F.png" class="" title="字典输出成功"><h2 id="7-参考文献"><a href="#7-参考文献" class="headerlink" title="7. 参考文献"></a>7. 参考文献</h2><p>[1]<a href="https://book.douban.com/subject/27180929/">罗攀,蒋仟.《从零开始学python网络爬虫》.机械工业出版社.2017：1-44</a></p><p>[2]<a href="https://www.jianshu.com/p/1977605177f9">Python 爬虫并且将数据写入Excel</a></p><p>[3]<a href="https://openpyxl.readthedocs.io/en/stable/tutorial.html">openpyxl库官方文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
